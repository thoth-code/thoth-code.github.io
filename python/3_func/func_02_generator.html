<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>article | Thoth</title>
    <link rel="stylesheet" href="../../style/font.css">
    <link rel="stylesheet" href="../../style/whiteboard.css">
  </head>
  <body>
    <header>
        <div id="logo"><div class="hov_box"><a href="../index.html">Thoth</a></div></div>
        <div id="title">함수선언</div>
    </header>
    <main>
      <article class="post">
        <h2>제네레이터</h2>
        <ul>
          <li>제네레이터는 어떤 많은 값들을 생성해서 사용해야할때 전부 다 만들어놓고 사용하는게 아닌 <strong>만드는 방법만 저장했다가 호출시에 바로바로 만들어 쓰는 개념</strong>이다</li>
          <li>대표적인예로 range()함수를 알아보자</li>
          <ul class="example">
            <li>5조5억개의 숫자를 생성해야한다고 가정해보자</li>
            <li>이때 l1 = [n+1 for n in range(0, 오조오억)]으로 그냥 리스트를 생성하고</li>
            <li>l2 = range(0, 오조오억)이렇게 해줬을때 두가지는 인덱스로 접근도 가능하고, iterate도 사용할 수 있으니 같은 기능을 제공한다고 할 수 있다</li>
            <li>심지어 len()으로 요소의 갯수를 구해도 같은 값을 출력한다</li>
            <li>하지만 이 둘의 메모리 소모를 보면 확연히 차이가 난다 : l2가 현저히 적은 양의 데이터를 먹는다</li>
            <li>이것은 l1는 오조오억개의 숫자를 미리 만들어서 저장하고 있지만, l2의 경우에는 숫자를 생성하는 방법만 저장하고 실질적으로 만든 숫자는 가지고 있지 않다</li>
            <li>따라서 제네레이터는 같은 기능을 제공하지만 현저히 적은 메모리를 먹는다는 장점이 있다</li>
          </ul>
          <li>일반 함수에서 제네레이터 기능 사용하기 : yield</li>
          <ul>
            <li>return같은 경우에는 반환하면 바로 함수가 종료되지만 <strong>yield의 경우에는 종료되지 않는다</strong></li>
            <li>return같은 경우에는 반환값이 그대로 반환되지만 <strong>yield는 제네레이터 객체가 반환된다</strong></li>
            <li><strong>next(반환된 제네레이터 객체)를 이용해 다음으로 함수가 반환할 값을 그때그때 받아서 쓸 수가 있다</strong></li>
            <li>이것도 return의 경우에는 값을 다 만들어서 반환하지만 yield의 경우에는 값을 만드는 방법을 저장했다가 <strong>next()로 호출할때마다 그때그때 값을 만들기 때문</strong>이다</li>
          </ul>
      </article>
    </main>
    <footer>
      copyright©saltwalks2021
    </footer>
  </body>
</html>
